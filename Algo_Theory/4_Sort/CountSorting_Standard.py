# 계수 정렬 (Count Sorting)
# 특정한 조건이 부합할 때만 사용할 수 있지만 매우 빠른 정렬 알고리즘
# 최악의 경우에도 시간 복잡도 O(N+K)를 보장한다.
# 조건 : 데이터의 크기 범위가 정수 형태로 표현할 수 있을 때 (실수형일 경우 사용하기 어렵다)
# 일반적으로 가장 큰 데이터와 가장 작은 데이터의 차이가 1,000,000을 넘지 않을 때 효과적으로 사용할 수 있다
# 1. 가장 큰 데이터와 가장 작은 데이터의 범위가 모두 담길 수 있는 크기이고 모든 원소가 0인 리스트를 생성
# 2. 데이터의 앞에서 부터 각 데이터의 숫자에 해당하는 인덱스의 크기를 1씩 증가시킴
# 3. 결국 생성한 리스트에는 각 데이터의 출현 빈도가 기록된다
# 4. 결과를 나타낼 때에는 인덱스의 숫자를 그 인덱스의 빈도수 만큼 출력하면 된다 ex) 001233344567789

# 모든 원소의 값이 0보다 크거나 같다고 가정
array = [7, 5, 9, 0, 3, 1, 6, 2, 9, 1, 4, 8, 0, 5, 2]
# 모든 범위를 포함하는 리스트 선언(모든 값은 0으로 초기화)
count = [0] * (max(array)+1)

for i in range(len(array)):
    count[array[i]] += 1 # 각 데이터에 해당하는 인덱스의 값 증

for i in range(len(count)):
    for j in range(count[i]):
        print(i, end=' ') # 띄어쓰기를 구분으로 등장한 횟수만큼 인덱스 출력

# 시간 복잡도 : O(N+K)
# 특정 조건만 맞다면 현존하는 정렬 알고리즘 중에서 기수 정렬(Radix Sorting)과 더불어 가장 빠르다
# 공간 복잡도(단점) : O(N+K) : 예를 들어 데이터가 0과 999,999 단 2개만 존재한다고 가정하면
# 데이터는 2개만 존재하지만 리스트를 생성할 때 리스트의 크기가 100만 개가 되도록 선언해야 한다.
# 동일한 값을 가지는 데이터가 여러 개 등장할 때 적합한 알고리즘이다
# 데이터의 특성을 파악하기 어렵다면 퀵 정렬(Quick Sorting)을 사용하는 것이 일반ㄷ적으로 유리하다.
