# 삽입 정렬(Insertion Sorting)
# 구현 난이도가 높은 편이지만 필요할 때만 위치를 바꾸므로
# "데이터가 거의 정렬되어 있을 때" 훨씬 효율적이다
# 1. 첫번째 원소를 그대로 두고 다음 원소와 비교하여 다음 원소를 첫 번째 원소 왼쪽에 넣을지 오른쪽에 넣을지 결정하고 넣음
# 2. 그 다음 원소를 첫번째 두번째 원소와 비교하여 어느 위치에 넣을지 결정하고 넣음
# 3. 반복 : 이렇게 적절한 위치에 삽입하는 과정을 N-1번 반복

array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]

for i in range(1, len(array)):
    for j in range(i, 0, -1): # 인덱스 i부터 1까지(i, 0) 1만큼 감소하며(-1) 반복하는 문법
        if array[j] < array[j-1]: # 한 칸씩 왼쪽으로 이동
            array[j], array[j-1] = array[j-1], array[j]
        else:
            break

print(array)

# 시간 복잡도 : O(N^2)
# 중요한 점 : 데이터가 거의 정렬되어 있는 상태라면 매우 빠르게 동작
# Best Case : O(N)
# 퀵 정렬(Quick Sorting)과 비교했을 때 보통은 비효율적이나 정렬이 거의 되어 있는 상황에서는 퀵 정렬보다 더 강력하다
